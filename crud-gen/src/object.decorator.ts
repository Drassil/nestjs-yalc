import { FieldMapperProperty, IFieldMapper } from '@nestjs-yalc/interfaces';
import { ClassType } from '@nestjs-yalc/types/globals';
import { isClass } from '@nestjs-yalc/utils/class.helper';
import {
  addFieldMetadata,
  FieldOptions,
  ReturnTypeFunc,
} from '@nestjs/graphql';
import 'reflect-metadata';
import { RelationType } from 'typeorm/metadata/types/RelationTypes';
import { IAgQueryParams } from './crud-gen.args';

export interface DstExtended {
  name: string;
  transformer: { (dstObj: Record<any, any>, srcValue: any): void };
}

export function isDstExtended(dst: string | DstExtended): dst is DstExtended {
  const _dst = dst as DstExtended;
  return !!_dst.name && !!_dst.transformer;
}

export interface ICrudGenFieldMetadata<T = any>
  extends Omit<FieldMapperProperty, 'dst'> {
  dst?: string | DstExtended;
  src?: string;

  /**
   * Sets the modality we want to retrieve the data
   *
   * * 'derived': the field exists on the datasource but is generated by an expression
   *  that can be defined in 'dst' (can be used for json fields or other syntax)
   * * 'regular (default)': the field exists on the datasource and is fetched regularly
   * * 'virtual' (not implemented): the field doesn't exist on the datasource and must be set programmatically
   *
   */
  mode?: 'derived' | 'regular' | 'virtual';

  /**
   * Nestjs/graphQL Field decorator options
   */
  gqlType?: ReturnTypeFunc;
  gqlOptions?: FieldOptions;
  /**
   * To specify if it's a resource that can be loaded with a dataLoader/join
   */
  relation?: {
    defaultValue?: IAgQueryParams<T>;
    sourceKey: {
      /** the mysql field name */
      dst: string;
      /** the graphql field name */
      alias: string;
    };
    /**
     * this is the field that will be used for both the dataloader and the join
     * For join: If the JoinColumn decorator exists on the same column, this key will be added
     * to the SQL `ON` condition
     */
    targetKey: {
      /** the mysql field name */
      dst: string;
      /** the graphql field name */
      alias: string;
    };
    relationType: RelationType;
    type: { (): ClassType };
  };

  /**
   * Internally used
   */
  _propertyName?: string;
}

export const CRUDGEN_OBJECT_METADATA_KEY = Symbol(
  'CRUDGEN_OBJECT_METADATA_KEY',
);
export const CRUDGEN_FIELD_METADATA_KEY = Symbol('CRUDGEN_FIELD_METADATA_KEY');

export function getPrototype(target: Record<string, unknown> | ClassType): any {
  return isClass(target) || !target.prototype ? target : target.prototype;
}

export const CrudGenField = <T = any>({
  gqlType,
  gqlOptions,
  ...options
}: ICrudGenFieldMetadata<T>): PropertyDecorator => {
  return (target: any, property: string | symbol) => {
    const classConstructor = target.constructor;
    const propertyName = property.toString();

    const metadata =
      Reflect.getMetadata(CRUDGEN_FIELD_METADATA_KEY, classConstructor) || {};

    // create new object reference to avoid this issue: https://github.com/rbuckton/reflect-metadata/issues/62
    const newMetadata: any = { ...metadata };

    const previousValues = metadata[propertyName];

    newMetadata[propertyName] = {
      ...previousValues,
      dst: previousValues?.dst ?? propertyName,
      src: gqlOptions?.name ?? propertyName,
      gqlType,
      gqlOptions,
      ...options,
      _propertyName: propertyName,
    };

    Reflect.defineMetadata(
      CRUDGEN_FIELD_METADATA_KEY,
      newMetadata,
      classConstructor,
    );

    // graphql field metadata
    if (gqlOptions || gqlType) {
      addFieldMetadata(
        <ReturnTypeFunc>gqlType ?? <FieldOptions>gqlOptions,
        gqlOptions ?? {},
        target,
        propertyName,
      );
    }
  };
};

export const getCrudGenFieldMetadataList = (
  target: Record<string, unknown> | ClassType,
): { [key: string]: ICrudGenFieldMetadata } | undefined => {
  return Reflect.getMetadata(CRUDGEN_FIELD_METADATA_KEY, getPrototype(target));
};

export const hasCrudGenFieldMetadataList = (
  target: Record<string, unknown> | ClassType,
): boolean => {
  return Reflect.hasMetadata(CRUDGEN_FIELD_METADATA_KEY, getPrototype(target));
};

export const getCrudGenFieldMetadata = (
  target: Record<string, unknown> | ClassType,
  propertyName: string | symbol,
): ICrudGenFieldMetadata | undefined => {
  const metadata = getCrudGenFieldMetadataList(target);

  const name = propertyName.toString();

  if (!metadata || !metadata[name]) return undefined;

  return metadata[name];
};

export const hasCrudGenFieldMetadata = (
  target: Record<string, unknown> | ClassType,
  propertyName: string,
): boolean => {
  const metadata = Reflect.getMetadata(
    CRUDGEN_FIELD_METADATA_KEY,
    getPrototype(target),
  );

  return metadata && !!metadata[propertyName];
};

export const CrudGenObject = (
  options?: CrudGenObjectOptions,
): ClassDecorator => {
  return (target) => {
    let metadata = options ?? {};

    if (metadata.copyFrom) {
      const copyFrom = metadata.copyFrom;
      metadata = { ...metadata, ...getCrudGenObjectMetadata(copyFrom) };

      const fieldMetadata = { ...getCrudGenFieldMetadataList(copyFrom) };

      Reflect.defineMetadata(CRUDGEN_FIELD_METADATA_KEY, fieldMetadata, target);
    }

    Reflect.defineMetadata(CRUDGEN_OBJECT_METADATA_KEY, metadata, target);
  };
};

export const getCrudGenObjectMetadata = (
  target: Record<string, unknown> | ClassType,
): FilterOption => {
  return Reflect.getMetadata(CRUDGEN_OBJECT_METADATA_KEY, getPrototype(target));
};

export const hasCrudGenObjectMetadata = (
  target: Record<string, unknown> | ClassType,
): boolean => {
  return Reflect.hasMetadata(CRUDGEN_OBJECT_METADATA_KEY, getPrototype(target));
};

/**
 * The options below allow to implement an include/exclude mechanism for mapped fields.
 * It can be used to deny the usage of certain fields
 */
export enum FilterOptionType {
  /** include fields specified inside the array of fields and exclude all the others */
  INCLUDE = 'include',
  /** exclude fields specified inside the array of fields and include all the others */
  EXCLUDE = 'exclude',
}

export type FilterOption = {
  type: FilterOptionType;
  fields: string[];
};

export type CrudGenObjectOptions = {
  /**
   * Copy crudGen decorator metadata from another class
   * Useful when the classes are similar but they don't share the prototype
   * E.G. when you use OmitType or similar techniques
   */
  copyFrom?: ClassType;
  filters?: FilterOption;
};

export interface IFieldAndFilterMapper {
  field: IFieldMapper;
  //When filterOption is set we can manage filters on fields with an inclusion/exclusion strategy
  filterOption?: FilterOption;
  extraInfo?: { [key: string]: any };
}
